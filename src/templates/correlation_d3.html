<!DOCTYPE html>
<html>

<head>
    <title>Correlations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        .vertical {
            flex-direction: column;
        }

        .horizontal {
            flex-direction: row;
        }

        .panel {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        #heatmap {
            width: 100%;
            height: 100%;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #heatmap svg {
            display: block;
            margin: auto;
            max-width: 100%;
            max-height: 100%;
        }

        #hover-panel {
            background-color: #2a2a2a;
            padding: 0;
            overflow-y: auto;
        }

        /* Only apply 6:4 ratio in split views */
        .vertical .panel:first-child,
        .horizontal .panel:first-child {
            flex: 0.6;
        }

        .vertical #hover-panel,
        .horizontal #hover-panel {
            flex: 0.4;
        }

        .filtered-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-size: 11px;
            table-layout: fixed;
        }

        .filtered-table th,
        .filtered-table td {
            padding: 4px;
            text-align: left;
            border-bottom: 1px solid #3a3a3a;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 11px;
        }

        .filtered-table th {
            background-color: #3a3a3a;
            position: sticky;
            top: 0;
            padding: 4px;
            border-right: 1px solid #4a4a4a;
        }

        .filtered-table th:last-child {
            border-right: none;
        }

        .filtered-table td {
            border-right: 1px solid #3a3a3a;
        }

        .filtered-table td:last-child {
            border-right: none;
        }

        .filtered-table tr:hover {
            background-color: #3a3a3a;
        }

        .filtered-table td:nth-child(1),
        .filtered-table td:nth-child(4) {
            width: 35%;
        }

        .filtered-table td:nth-child(2),
        .filtered-table td:nth-child(3),
        .filtered-table td:nth-child(5),
        .filtered-table td:nth-child(6) {
            width: 3%;
            text-align: right;
            color: #888;
            padding: 4px 2px;
            white-space: nowrap;
            overflow: visible;
            text-overflow: clip;
        }

        .filtered-table th:nth-child(2),
        .filtered-table th:nth-child(3),
        .filtered-table th:nth-child(5),
        .filtered-table th:nth-child(6) {
            width: 3%;
            text-align: right;
            padding: 4px 2px;
            white-space: nowrap;
            overflow: visible;
            text-overflow: clip;
        }

        .filtered-table td:nth-child(7) {
            width: 10%;
            text-align: right;
        }

        .filtered-table th:nth-child(7) {
            width: 10%;
            text-align: right;
        }

        .controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            border-radius: 5px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            cursor: move;
            width: 250px;
            box-sizing: border-box;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transform: translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
        }

        .button-group {
            display: flex;
            gap: 2px;
            width: 100%;
            padding: 5px;
            background-color: rgba(42, 42, 42, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-sizing: border-box;
            transform: translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
        }

        .button-group button {
            flex: 1;
            min-width: 0;
            box-sizing: border-box;
        }

        .drawing-mode {
            background-color: #ff4444 !important;
        }

        .selection-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(42, 42, 42, 0.8);
            border-radius: 5px;
            padding: 10px 10px 12px 10px;
            display: none;
            width: 400px;
            overflow-y: auto;
            cursor: move;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-sizing: border-box;
            transform: translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        .mini-heatmap {
            width: 100%;
            height: 100px;
            margin-bottom: 10px;
            background-color: transparent;
            border-radius: 3px;
            overflow: hidden;
        }

        .mini-heatmap svg {
            width: 100%;
            height: 100%;
        }

        .selection-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .selection-panel h3 {
            margin: 0;
            font-size: 14px;
            user-select: none;
            flex: 1;
            text-align: left;
        }

        .selection-panel .close-btn {
            background: #444;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            font-size: 16px;
            line-height: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            transition: background 0.2s;
        }

        .selection-panel .copy-btn {
            background: #444;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            font-size: 14px;
            line-height: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            transition: background 0.2s;
        }

        .selection-panel .close-btn:hover,
        .selection-panel .copy-btn:hover {
            background: #ff4444;
        }

        .selection-panel-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .selection-panel label {
            font-size: 12px;
            user-select: none;
            margin-bottom: 2px;
            margin-left: 2px;
        }

        .selection-panel textarea {
            width: 100%;
            min-width: 0;
            height: 80px;
            margin: 0;
            background-color: #2a2a2a;
            color: white;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            padding: 5px;
            resize: vertical;
            box-sizing: border-box;
            display: block;
        }

        .selection-panel .panel-section {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            margin-bottom: 6px;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 5px;
            background-color: rgba(42, 42, 42, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            width: 100%;
            box-sizing: border-box;
            transform: translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        .colormap-group {
            display: flex;
            gap: 2px;
            width: 100%;
            padding: 5px;
            background-color: rgba(42, 42, 42, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-sizing: border-box;
            transform: translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
        }

        .colormap-group button {
            flex: 1;
            min-width: 0;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }

        .colormap-group button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.3;
            pointer-events: none;
        }

        .colormap-group button[data-colormap="rdbu"]::before {
            background: linear-gradient(to right, #b2182b, #ffffff, #2166ac);
        }

        .colormap-group button[data-colormap="viridis"]::before {
            background: linear-gradient(to right, #440154, #21918c, #fde725);
        }

        .colormap-group button[data-colormap="plasma"]::before {
            background: linear-gradient(to right, #00204c, #7e7f3e, #fdea45);
        }

        .colormap-group button[data-colormap="cividis"]::before {
            background: linear-gradient(to right, #00204c, #7e7f3e, #fdea45);
        }

        .colormap-group button[data-colormap="inferno"]::before {
            background: linear-gradient(to right, #000004, #bc3754, #fcfdbf);
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
            color: white;
            font-size: 11px;
            min-height: 130px;
            background-color: rgba(42, 42, 42, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 5px;
            border-radius: 3px;
            box-sizing: border-box;
            transform: translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
        }

        .slider-container label {
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            overflow: hidden;
        }

        .slider-container label span:first-child {
            flex-shrink: 0;
        }

        .slider-container label span:last-child {
            flex-shrink: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .slider-container input {
            width: 100%;
            margin: 0;
        }

        #histogram,
        #length-histogram {
            width: 100%;
            height: 100px;
            margin-top: 2px;
        }

        button {
            background-color: #3a3a3a;
            color: white;
            border: none;
            padding: 4px 8px;
            margin: 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        button:hover {
            background-color: #4a4a4a;
        }

        button.active {
            background-color: #5a5a5a;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(42, 42, 42, 0.9);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            white-space: pre-wrap;
        }

        /* Loading spinner styles */
        .spinner-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 26, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #ff4444;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .guideline {
            stroke: #ffffff;
            stroke-width: 1.5;
            stroke-dasharray: 2;
            pointer-events: none;
        }

        .guideline-text {
            fill: #ffffff;
            font-size: 12px;
            pointer-events: none;
            background-color: rgba(42, 42, 42, 0.9);
            padding: 4px;
            border-radius: 4px;
        }

        .guideline-text-bg {
            fill: rgba(42, 42, 42, 0.9);
            rx: 4;
            ry: 4;
        }
    </style>
</head>

<body>
    <div class="spinner-container" id="spinner">
        <div class="spinner"></div>
    </div>
    <div class="controls">
        <div class="button-group">
            <button id="single" class="active">Single</button>
            <button id="vertical">Vertical</button>
            <button id="horizontal">Horizontal</button>
        </div>
        <div class="slider-group">
            <div class="slider-container">
                <label for="threshold">Similarity: <span id="threshold-value">0.0</span> (<span
                        id="threshold-count">0</span> values)</label>
                <input type="range" id="threshold" min="-1" max="1" step="0.01" value="-1">
                <div id="histogram"></div>
            </div>
            <div class="slider-container">
                <label for="length-threshold">Length: <span id="length-value">0</span> chars (<span
                        id="length-count">0</span> values)</label>
                <input type="range" id="length-threshold" min="0" max="1000" step="1" value="0">
                <div id="length-histogram"></div>
            </div>
            <div class="colormap-group">
                <button data-colormap="rdbu" class="active">RdBu</button>
                <button data-colormap="viridis">Viridis</button>
                <button data-colormap="cividis">Cividis</button>
                <button data-colormap="inferno">Inferno</button>
            </div>
        </div>
    </div>
    <div class="container" id="container">
        <div class="panel">
            <div id="heatmap"></div>
        </div>
        <div class="panel" id="hover-panel" style="display: none;">
            <table class="filtered-table">
                <thead>
                    <tr>
                        <th id="row-header">Content 1</th>
                        <th>Offset 1</th>
                        <th>Length 1</th>
                        <th id="col-header">Content 2</th>
                        <th>Offset 2</th>
                        <th>Length 2</th>
                        <th>Similarity</th>
                    </tr>
                </thead>
                <tbody id="filtered-correlations"></tbody>
            </table>
        </div>
    </div>
    <div class="selection-panel" id="selection-panel">
        <div class="selection-panel-header">
            <h3>Selected Area</h3>
            <div style="display: flex; gap: 4px;">
                <button class="copy-btn" id="copy-selection" title="Copy">📋</button>
                <button class="close-btn" id="close-selection" title="Close">&times;</button>
            </div>
        </div>
        <div class="mini-heatmap" id="mini-heatmap"></div>
        <div class="selection-panel-content">
            <div class="panel-section">
                <label for="row-chunks" id="row-chunks-label"></label>
                <textarea id="row-chunks" readonly></textarea>
            </div>
            <div class="panel-section">
                <label for="col-chunks" id="col-chunks-label"></label>
                <textarea id="col-chunks" readonly></textarea>
            </div>
        </div>
    </div>
    <div class="tooltip" style="display: none;"></div>
    <script>
        // Helper function to wrap text
        function wrapText(text, maxLen = 50) {
            if (text.length <= maxLen) return text.trim();
            const remaining = text.length - maxLen;
            return text.slice(0, maxLen).trim() + ` (...${remaining} chars)`;
        }

        // Helper function to format hover text
        function formatHoverText(row, col, rowOff, rowLen, colOff, colLen, similarity) {
            return `[X${colOff}: ${colLen}]: ${wrapText(col)}\n[Y${rowOff}: ${rowLen}]: ${wrapText(row)}\nS(X${colOff}, Y${rowOff}): ${similarity.toFixed(4)}`;
        }

        // Parse data from template
        const data = {{ DATA }};
        let nRows = data.rowLabels.length;
        let nCols = data.colLabels.length;

        // Get filenames from the data
        const rowFile = data.rowFile || 'File 1';
        const colFile = data.colFile || 'File 2';

        // Update table headers with filenames
        document.getElementById('row-header').textContent = rowFile;
        document.getElementById('col-header').textContent = colFile;

        // Transpose the matrix if rows > columns to better utilize screen space
        let matrix = data.matrix;
        let rowLabels = data.rowLabels;
        let colLabels = data.colLabels;
        let rowFull = data.rowFull;
        let colFull = data.colFull;

        if (nRows > nCols) {
            matrix = matrix[0].map((_, i) => matrix.map(row => row[i]));
            [rowLabels, colLabels] = [colLabels, rowLabels];
            [rowFull, colFull] = [colFull, rowFull];
            [nRows, nCols] = [nCols, nRows];
        }

        // Create color scale
        let colorScale = d3.scaleSequential()
            .domain([1, -1])  // Will be updated dynamically
            .interpolator(d3.interpolateRdBu);

        // Create tooltip
        const tooltip = d3.select('.tooltip');

        // Create heatmap
        function createHeatmap() {
            // Show spinner
            document.getElementById('spinner').style.display = 'flex';

            const container = d3.select('#heatmap');
            const containerWidth = container.node().getBoundingClientRect().width;
            const containerHeight = container.node().getBoundingClientRect().height;

            // Calculate cell size to ensure squares, accounting for padding
            const padding = { top: 20, right: 20, bottom: 20, left: 20 };
            const availableWidth = containerWidth - padding.left - padding.right;
            const availableHeight = containerHeight - padding.top - padding.bottom;
            const maxCellWidth = availableWidth / nCols;
            const maxCellHeight = availableHeight / nRows;
            const cellSize = Math.min(maxCellWidth, maxCellHeight);

            // Calculate total width and height to maintain square cells
            const width = cellSize * nCols;
            const height = cellSize * nRows;
            const totalWidth = width + padding.left + padding.right;
            const totalHeight = height + padding.top + padding.bottom;

            const svg = container.append('svg')
                .attr('width', totalWidth)
                .attr('height', totalHeight)
                .style('display', 'block')
                .style('margin', 'auto');

            // Main group for the heatmap
            const g = svg.append('g')
                .attr('transform', `translate(${padding.left},${padding.top})`);

            // Create cells
            const cells = g.selectAll('rect')
                .data(d3.range(nRows * nCols))
                .enter()
                .append('rect')
                .attr('x', d => (d % nCols) * cellSize)
                .attr('y', d => Math.floor(d / nCols) * cellSize)
                .attr('width', cellSize)
                .attr('height', cellSize)
                .style('cursor', 'pointer')
                .attr('fill', d => {
                    const i = Math.floor(d / nCols);
                    const j = d % nCols;
                    const value = matrix[i][j];
                    const rowLen = rowFull[i].length;
                    const colLen = colFull[j].length;
                    const simThreshold = parseFloat(document.getElementById('threshold').value);
                    const lenThreshold = parseInt(document.getElementById('length-threshold').value);
                    const meetsThresholds = value >= simThreshold && rowLen >= lenThreshold && colLen >= lenThreshold;

                    return meetsThresholds ? colorScale(value) : '#444444';
                })
                .on('mouseover', function (event, d) {
                    const i = Math.floor(d / nCols);
                    const j = d % nCols;
                    const value = matrix[i][j];
                    const rowLen = rowFull[i].length;
                    const colLen = colFull[j].length;
                    const simThreshold = parseFloat(document.getElementById('threshold').value);
                    const lenThreshold = parseInt(document.getElementById('length-threshold').value);
                    const meetsThresholds = value >= simThreshold && rowLen >= lenThreshold && colLen >= lenThreshold;

                    const text = formatHoverText(
                        rowFull[i],
                        colFull[j],
                        i,
                        rowLen,
                        j,
                        colLen,
                        value
                    ) + (meetsThresholds ? '' : '\n(Below threshold)');

                    tooltip
                        .style('display', 'block')
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY + 10) + 'px')
                        .html(text.replace(/\n/g, '<br>'));
                })
                .on('mouseout', function () {
                    tooltip.style('display', 'none');
                })
                .on('click', function (event, d) {
                    const i = Math.floor(d / nCols);
                    const j = d % nCols;
                    const value = matrix[i][j];
                    const rowLen = rowFull[i].length;
                    const colLen = colFull[j].length;
                    const simThreshold = parseFloat(document.getElementById('threshold').value);
                    const lenThreshold = parseInt(document.getElementById('length-threshold').value);
                    const meetsThresholds = value >= simThreshold && rowLen >= lenThreshold && colLen >= lenThreshold;

                    if (!meetsThresholds) return;

                    // Remove existing guidelines if any
                    svg.selectAll('.guideline-group').remove();

                    // Get SVG's position relative to the container
                    const svgRect = svg.node().getBoundingClientRect();
                    const containerRect = d3.select('#heatmap').node().getBoundingClientRect();
                    const svgOffsetX = svgRect.left - containerRect.left;
                    const svgOffsetY = svgRect.top - containerRect.top;

                    // Create new guideline group
                    const guidelineGroup = svg.append('g')
                        .attr('class', 'guideline-group')
                        .attr('transform', `translate(${padding.left},${padding.top})`);

                    // Calculate positions
                    const x = j * cellSize + cellSize / 2;
                    const y = i * cellSize + cellSize / 2;

                    // Add guidelines
                    guidelineGroup.append('line')
                        .attr('class', 'guideline')
                        .attr('x1', 0)
                        .attr('x2', width)
                        .attr('y1', y)
                        .attr('y2', y);

                    guidelineGroup.append('line')
                        .attr('class', 'guideline')
                        .attr('x1', x)
                        .attr('x2', x)
                        .attr('y1', 0)
                        .attr('y2', height);

                    // Prepare text content
                    const rowText = `[Y${i}: ${rowLen}]: ${wrapText(rowFull[i])}`;
                    const colText = `[X${j}: ${colLen}]: ${wrapText(colFull[j])}`;
                    const simText = `S(X${j}, Y${i}): ${value.toFixed(4)}`;

                    // Function to create text with background
                    function createTextWithBg(x, y, text) {
                        const textElement = guidelineGroup.append('text')
                            .attr('class', 'guideline-text')
                            .attr('x', x)
                            .attr('y', y)
                            .text(text);

                        const bbox = textElement.node().getBBox();
                        guidelineGroup.insert('rect', 'text')
                            .attr('class', 'guideline-text-bg')
                            .attr('x', bbox.x - 4)
                            .attr('y', bbox.y - 4)
                            .attr('width', bbox.width + 8)
                            .attr('height', bbox.height + 8);
                    }

                    // Add text overlays with backgrounds
                    createTextWithBg(x + 10, y - 10, colText);
                    createTextWithBg(x + 10, y + 20, rowText);

                    // Remove any existing click handler
                    document.removeEventListener('click', window.clearGuidelines);

                    // Add click handler to clear guidelines
                    window.clearGuidelines = function (event) {
                        // Don't clear if clicking on the same cell
                        const target = event.target;
                        if (target.tagName === 'rect' && target.parentNode === g.node()) {
                            const rectX = parseFloat(target.getAttribute('x'));
                            const rectY = parseFloat(target.getAttribute('y'));
                            const clickedI = Math.floor(rectY / cellSize);
                            const clickedJ = Math.floor(rectX / cellSize);
                            if (clickedI === i && clickedJ === j) {
                                return;
                            }
                        }
                        svg.selectAll('.guideline-group').remove();
                        document.removeEventListener('click', window.clearGuidelines);
                    };

                    // Add slight delay to prevent immediate clearing
                    setTimeout(() => {
                        document.addEventListener('click', window.clearGuidelines);
                    }, 100);
                });

            // Add x-axis label
            svg.append('text')
                .attr('x', totalWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('fill', '#ffffff')
                .attr('font-size', '12px')
                .text(`X: ${colFile} (${nCols} chunks)`);

            // Add y-axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -totalHeight / 2)
                .attr('y', 10)
                .attr('text-anchor', 'middle')
                .attr('fill', '#ffffff')
                .attr('font-size', '12px')
                .text(`Y: ${rowFile} (${nRows} chunks)`);

            // Hide spinner after a short delay to ensure smooth rendering
            setTimeout(() => {
                document.getElementById('spinner').style.display = 'none';
            }, 100);

            return { svg, g, cells, cellSize, padding, width, height };
        }

        // Create histogram
        function createHistogram(container, data, domain, threshold = 0) {
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;

            const x = d3.scaleLinear()
                .domain(domain)
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data)])
                .range([height, 0]);

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g');

            // Create bars
            const barWidth = width / data.length;
            g.selectAll('rect')
                .data(data)
                .enter()
                .append('rect')
                .attr('x', (d, i) => i * barWidth)
                .attr('y', d => y(d))
                .attr('width', barWidth - 1)
                .attr('height', d => height - y(d))
                .attr('fill', '#4a4a4a');

            // Add threshold line
            const thresholdLine = g.append('line')
                .attr('x1', x(threshold))
                .attr('x2', x(threshold))
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', '#ff0000')
                .attr('stroke-width', 2);

            return { svg, g, thresholdLine, x, y };
        }

        // Initialize visualizations
        const heatmap = createHeatmap();

        // Drawing mode variables
        let isDrawing = false;
        let startX, startY;
        let selectionRect = null;
        let selectionBBox = null;

        document.getElementById('close-selection').addEventListener('click', function () {
            document.getElementById('selection-panel').style.display = 'none';
        });

        document.getElementById('copy-selection').addEventListener('click', function () {
            const rowChunks = document.getElementById('row-chunks').value;
            const colChunks = document.getElementById('col-chunks').value;
            const rowLabel = document.getElementById('row-chunks-label').textContent;
            const colLabel = document.getElementById('col-chunks-label').textContent;

            const formattedText = `[${rowLabel}]\n${rowChunks}\n\n==========================================\n\n[${colLabel}]\n${colChunks}`;

            navigator.clipboard.writeText(formattedText).then(() => {
                // Visual feedback for copy
                const btn = this;
                const originalText = btn.textContent;
                btn.textContent = '✓';
                btn.style.background = '#4CAF50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 1000);
            });
        });

        function clearSelection() {
            if (selectionRect) {
                selectionRect.remove();
                selectionRect = null;
                selectionBBox = null;
            }
            document.getElementById('selection-panel').style.display = 'none';
        }

        // Add drawing functionality to heatmap
        heatmap.svg
            .on('mousedown', function (event) {
                // If clicking inside the selection, do nothing (allow drag to start new selection)
                if (selectionBBox) {
                    const [mx, my] = d3.pointer(event);
                    if (
                        mx >= selectionBBox.x &&
                        mx <= selectionBBox.x + selectionBBox.width &&
                        my >= selectionBBox.y &&
                        my <= selectionBBox.y + selectionBBox.height
                    ) {
                        // Allow drag to start new selection
                    } else {
                        clearSelection();
                        return;
                    }
                }
                isDrawing = true;
                const [x, y] = d3.pointer(event);
                startX = x;
                startY = y;
                if (selectionRect) {
                    selectionRect.remove();
                    selectionRect = null;
                }
                selectionRect = heatmap.svg.append('rect')
                    .attr('x', x)
                    .attr('y', y)
                    .attr('width', 0)
                    .attr('height', 0)
                    .attr('fill', 'rgba(255, 68, 68, 0.2)')
                    .attr('stroke', '#ff4444')
                    .attr('stroke-width', 2);
            })
            .on('mousemove', function (event) {
                if (!isDrawing || !selectionRect) return;
                const [x, y] = d3.pointer(event);
                const width = x - startX;
                const height = y - startY;
                selectionRect
                    .attr('width', Math.abs(width))
                    .attr('height', Math.abs(height))
                    .attr('x', width < 0 ? x : startX)
                    .attr('y', height < 0 ? y : startY);
            })
            .on('mouseup', function (event) {
                if (!isDrawing || !selectionRect) return;
                isDrawing = false;
                const [x, y] = d3.pointer(event);
                const rect = selectionRect.node().getBBox();
                selectionBBox = rect;

                // Get SVG's position relative to the container
                const svgRect = heatmap.svg.node().getBoundingClientRect();
                const containerRect = d3.select('#heatmap').node().getBoundingClientRect();
                const svgOffsetX = svgRect.left - containerRect.left;
                const svgOffsetY = svgRect.top - containerRect.top;

                // Convert screen coordinates to cell indices, accounting for SVG offset
                const startRow = Math.floor((rect.y - heatmap.padding.top) / heatmap.cellSize);
                const endRow = Math.floor((rect.y + rect.height - heatmap.padding.top) / heatmap.cellSize);
                const startCol = Math.floor((rect.x - heatmap.padding.left) / heatmap.cellSize);
                const endCol = Math.floor((rect.x + rect.width - heatmap.padding.left) / heatmap.cellSize);

                // Get selected chunks
                const selectedRows = rowFull.slice(Math.max(0, startRow), Math.min(nRows, endRow + 1));
                const selectedCols = colFull.slice(Math.max(0, startCol), Math.min(nCols, endCol + 1));

                // Update selection panel
                const rowLabel = `${rowFile} ${selectedRows.length} chunk${selectedRows.length === 1 ? '' : 's'}`;
                const colLabel = `${colFile} ${selectedCols.length} chunk${selectedCols.length === 1 ? '' : 's'}`;
                document.getElementById('row-chunks-label').textContent = rowLabel;
                document.getElementById('col-chunks-label').textContent = colLabel;
                document.getElementById('row-chunks').value = selectedRows.join('\n\n');
                document.getElementById('col-chunks').value = selectedCols.join('\n\n');
                document.getElementById('selection-panel').style.display = 'block';

                // Create mini heatmap
                createMiniHeatmap(selectedRows, selectedCols, Math.max(0, startRow), Math.max(0, startCol));
            });

        // Compute histograms
        const simHistogram = d3.histogram()
            .domain([-1, 1])
            .thresholds(50)(matrix.flat().filter(d => !isNaN(d)));

        const lengthHistogram = d3.histogram()
            .domain([0, Math.max(...rowFull.map(d => d.length), ...colFull.map(d => d.length))])
            .thresholds(50)([...rowFull, ...colFull].map(d => d.length));

        const simHist = createHistogram(
            d3.select('#histogram'),
            simHistogram.map(d => d.length),
            [-1, 1]
        );

        const lenHist = createHistogram(
            d3.select('#length-histogram'),
            lengthHistogram.map(d => d.length),
            [0, lengthHistogram[lengthHistogram.length - 1].x1]
        );

        // Update visualizations based on thresholds
        function updateVisualization(simThreshold, lenThreshold) {
            let aboveThreshold = 0;
            let aboveLengthThreshold = 0;
            const correlations = [];
            let minValue = Infinity;
            let maxValue = -Infinity;

            // First pass: find min/max values in the matrix
            for (let i = 0; i < nRows; i++) {
                for (let j = 0; j < nCols; j++) {
                    const value = matrix[i][j];
                    if (!isNaN(value)) {
                        minValue = Math.min(minValue, value);
                        maxValue = Math.max(maxValue, value);
                    }
                }
            }

            // Update color scale domain
            colorScale.domain([maxValue, minValue]);

            // Update heatmap
            heatmap.cells
                .attr('fill', d => {
                    const i = Math.floor(d / nCols);
                    const j = d % nCols;
                    const value = matrix[i][j];
                    const rowLen = rowFull[i].length;
                    const colLen = colFull[j].length;
                    const meetsThresholds = value >= simThreshold && rowLen >= lenThreshold && colLen >= lenThreshold;

                    if (meetsThresholds) {
                        aboveThreshold++;
                        correlations.push({
                            row: rowFull[i],
                            col: colFull[j],
                            rowLen,
                            rowOff: i,
                            colLen,
                            colOff: j,
                            similarity: value
                        });
                    }
                    if (rowLen >= lenThreshold && colLen >= lenThreshold) {
                        aboveLengthThreshold++;
                    }

                    return meetsThresholds ? colorScale(value) : '#444444';
                })
                .style('cursor', d => {
                    const i = Math.floor(d / nCols);
                    const j = d % nCols;
                    const value = matrix[i][j];
                    const rowLen = rowFull[i].length;
                    const colLen = colFull[j].length;
                    return (value >= simThreshold && rowLen >= lenThreshold && colLen >= lenThreshold) ? 'pointer' : 'default';
                });

            // Update histograms
            simHist.thresholdLine
                .attr('x1', simHist.x(simThreshold))
                .attr('x2', simHist.x(simThreshold));

            lenHist.thresholdLine
                .attr('x1', lenHist.x(lenThreshold))
                .attr('x2', lenHist.x(lenThreshold));

            // Update counts
            document.getElementById('threshold-count').textContent = aboveThreshold;
            document.getElementById('length-count').textContent = aboveLengthThreshold;

            // Update table
            // Sort by how close similarity is to the threshold (but above threshold)
            correlations.sort((a, b) => (a.similarity - simThreshold) - (b.similarity - simThreshold));
            const closestCorrelations = correlations.slice(0, 100);

            const tbody = document.getElementById('filtered-correlations');
            tbody.innerHTML = '';

            closestCorrelations.forEach(corr => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td title="${corr.row}">${corr.row}</td>
                    <td>${corr.rowOff}</td>
                    <td>${corr.rowLen}</td>
                    <td title="${corr.col}">${corr.col}</td>
                    <td>${corr.colOff}</td>
                    <td>${corr.colLen}</td>
                    <td>${corr.similarity.toFixed(4)}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // Handle window resize
        function handleResize() {
            // Show spinner during resize
            document.getElementById('spinner').style.display = 'flex';

            const container = d3.select('#heatmap');
            const containerWidth = container.node().getBoundingClientRect().width;
            const containerHeight = container.node().getBoundingClientRect().height;

            // Calculate cell size to ensure squares, accounting for padding
            const padding = { top: 20, right: 20, bottom: 20, left: 20 };
            const availableWidth = containerWidth - padding.left - padding.right;
            const availableHeight = containerHeight - padding.top - padding.bottom;
            const maxCellWidth = availableWidth / nCols;
            const maxCellHeight = availableHeight / nRows;
            const cellSize = Math.min(maxCellWidth, maxCellHeight);

            // Calculate total width and height to maintain square cells
            const width = cellSize * nCols;
            const height = cellSize * nRows;
            const totalWidth = width + padding.left + padding.right;
            const totalHeight = height + padding.top + padding.bottom;

            heatmap.svg
                .attr('width', totalWidth)
                .attr('height', totalHeight);

            heatmap.g
                .attr('transform', `translate(${padding.left},${padding.top})`);

            // Update guideline group transform if it exists
            heatmap.svg.selectAll('.guideline-group')
                .attr('transform', `translate(${padding.left},${padding.top})`);

            heatmap.cells
                .attr('x', d => (d % nCols) * cellSize)
                .attr('y', d => Math.floor(d / nCols) * cellSize)
                .attr('width', cellSize)
                .attr('height', cellSize);

            // Update axis labels
            heatmap.svg.selectAll('text').remove();

            // Add x-axis label
            heatmap.svg.append('text')
                .attr('x', totalWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('fill', '#ffffff')
                .attr('font-size', '12px')
                .text(`${colFile} (${nCols} chunks)`);

            // Add y-axis label
            heatmap.svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -totalHeight / 2)
                .attr('y', 10)
                .attr('text-anchor', 'middle')
                .attr('fill', '#ffffff')
                .attr('font-size', '12px')
                .text(`${rowFile} (${nRows} chunks)`);

            updateVisualization(
                parseFloat(document.getElementById('threshold').value),
                parseInt(document.getElementById('length-threshold').value)
            );

            // Hide spinner after a short delay
            setTimeout(() => {
                document.getElementById('spinner').style.display = 'none';
            }, 100);
        }

        window.addEventListener('resize', handleResize);

        // Handle layout switching
        const container = document.getElementById('container');
        const hoverPanel = document.getElementById('hover-panel');
        const buttons = document.querySelectorAll('.controls button');

        function setLayout(layout) {
            buttons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(layout).classList.add('active');

            container.className = 'container';
            hoverPanel.style.display = 'none';

            if (layout === 'vertical') {
                container.classList.add('vertical');
                hoverPanel.style.display = 'block';
            } else if (layout === 'horizontal') {
                container.classList.add('horizontal');
                hoverPanel.style.display = 'block';
            }

            setTimeout(handleResize, 0);
        }

        buttons.forEach(button => {
            button.addEventListener('click', () => setLayout(button.id));
        });

        // Add threshold slider event listeners
        const thresholdSlider = document.getElementById('threshold');
        const thresholdValue = document.getElementById('threshold-value');
        const lengthSlider = document.getElementById('length-threshold');
        const lengthValue = document.getElementById('length-value');

        thresholdSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            thresholdValue.textContent = value.toFixed(2);
            updateVisualization(value, parseInt(lengthSlider.value));
        });

        lengthSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            lengthValue.textContent = value;
            updateVisualization(parseFloat(thresholdSlider.value), value);
        });

        // Initial update
        thresholdValue.textContent = thresholdSlider.value;
        updateVisualization(-1, 0);

        // Make the controls panel draggable
        (function () {
            const panel = document.querySelector('.controls');
            let isDragging = false;
            let offsetX = 0;
            let offsetY = 0;

            panel.addEventListener('mousedown', function (e) {
                // Only start drag if not clicking on a slider or button
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
                isDragging = true;
                offsetX = e.clientX - panel.getBoundingClientRect().left;
                offsetY = e.clientY - panel.getBoundingClientRect().top;
                panel.style.transition = 'none';
            });

            document.addEventListener('mousemove', function (e) {
                if (!isDragging) return;
                let x = e.clientX - offsetX;
                let y = e.clientY - offsetY;
                // Clamp to window bounds
                x = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, x));
                y = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, y));
                panel.style.left = x + 'px';
                panel.style.top = y + 'px';
                panel.style.right = 'auto';
            });

            document.addEventListener('mouseup', function () {
                isDragging = false;
                panel.style.transition = '';
            });
        })();

        // Make the selection panel draggable
        (function () {
            const panel = document.getElementById('selection-panel');
            let isDragging = false;
            let offsetX = 0;
            let offsetY = 0;

            panel.addEventListener('mousedown', function (e) {
                // Only start drag if not clicking on a textarea or button
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'BUTTON') return;
                isDragging = true;
                offsetX = e.clientX - panel.getBoundingClientRect().left;
                offsetY = e.clientY - panel.getBoundingClientRect().top;
                panel.style.transition = 'none';
            });

            document.addEventListener('mousemove', function (e) {
                if (!isDragging) return;
                let x = e.clientX - offsetX;
                let y = e.clientY - offsetY;
                // Clamp to window bounds
                x = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, x));
                y = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, y));
                panel.style.left = x + 'px';
                panel.style.top = y + 'px';
            });

            document.addEventListener('mouseup', function () {
                isDragging = false;
                panel.style.transition = '';
            });
        })();

        // Function to update color scale
        function updateColorScale(colormap) {
            // Find min and max values in the matrix
            let minValue = Infinity;
            let maxValue = -Infinity;
            for (let i = 0; i < nRows; i++) {
                for (let j = 0; j < nCols; j++) {
                    const value = matrix[i][j];
                    if (!isNaN(value)) {
                        minValue = Math.min(minValue, value);
                        maxValue = Math.max(maxValue, value);
                    }
                }
            }

            switch (colormap) {
                case 'viridis':
                    colorScale = d3.scaleSequential()
                        .domain([minValue, maxValue])
                        .interpolator(t => d3.interpolateViridis((t - minValue) / (maxValue - minValue)));
                    break;
                case 'cividis':
                    colorScale = d3.scaleSequential()
                        .domain([minValue, maxValue])
                        .interpolator(t => d3.interpolateCividis((maxValue - t) / (maxValue - minValue)));
                    break;
                case 'inferno':
                    colorScale = d3.scaleSequential()
                        .domain([minValue, maxValue])
                        .interpolator(t => d3.interpolateInferno((maxValue - t) / (maxValue - minValue)));
                    break;
                default: // rdbu
                    colorScale = d3.scaleSequential()
                        .domain([minValue, maxValue])
                        .interpolator(d3.interpolateRdBu);
            }
            updateVisualization(
                parseFloat(document.getElementById('threshold').value),
                parseInt(document.getElementById('length-threshold').value)
            );
        }

        // Add colormap button event listeners
        document.querySelectorAll('.colormap-group button').forEach(button => {
            button.addEventListener('click', function () {
                document.querySelectorAll('.colormap-group button').forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                updateColorScale(this.dataset.colormap);
            });
        });

        // Function to create mini heatmap
        function createMiniHeatmap(selectedRows, selectedCols, startRow, startCol) {
            const container = d3.select('#mini-heatmap');
            container.selectAll('*').remove();

            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;

            // Add padding for labels
            const padding = { top: 15, right: 15, bottom: 15, left: 15 };
            const innerWidth = width - padding.left - padding.right;
            const innerHeight = height - padding.top - padding.bottom;

            // Calculate cell size to ensure squares
            const maxCellWidth = innerWidth / selectedCols.length;
            const maxCellHeight = innerHeight / selectedRows.length;
            const cellSize = Math.min(maxCellWidth, maxCellHeight);

            // Calculate total width and height to maintain square cells
            const totalWidth = cellSize * selectedCols.length;
            const totalHeight = cellSize * selectedRows.length;

            // Center the heatmap in the available space
            const xOffset = padding.left + (innerWidth - totalWidth) / 2;
            const yOffset = padding.top + (innerHeight - totalHeight) / 2;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${xOffset},${yOffset})`);

            // Create cells
            g.selectAll('rect')
                .data(d3.range(selectedRows.length * selectedCols.length))
                .enter()
                .append('rect')
                .attr('x', d => (d % selectedCols.length) * cellSize)
                .attr('y', d => Math.floor(d / selectedCols.length) * cellSize)
                .attr('width', cellSize)
                .attr('height', cellSize)
                .attr('fill', d => {
                    const i = Math.floor(d / selectedCols.length);
                    const j = d % selectedCols.length;
                    const value = matrix[startRow + i][startCol + j];
                    return colorScale(value);
                });

            // Add x-axis label at the top (shorthand)
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 10)
                .attr('text-anchor', 'middle')
                .attr('fill', '#ffffff')
                .attr('font-size', '10px')
                .text(`X${startCol}-X${startCol + selectedCols.length - 1}`);

            // Add y-axis label, close to the left edge of the heatmap, vertically centered (shorthand)
            svg.append('text')
                .attr('transform', `rotate(-90)`)
                .attr('x', -((yOffset + totalHeight / 2)))
                .attr('y', Math.max(8, xOffset - 6))
                .attr('text-anchor', 'middle')
                .attr('fill', '#ffffff')
                .attr('font-size', '10px')
                .text(`Y${startRow}-Y${startRow + selectedRows.length - 1}`);

            return { svg, g };
        }
    </script>
</body>

</html>