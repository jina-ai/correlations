<!DOCTYPE html>
<html>

<head>
    <title>Embedding Correlations</title>
    <script src="https://cdn.plot.ly/plotly-2.29.0.min.js"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        .vertical {
            flex-direction: column;
        }

        .horizontal {
            flex-direction: row;
        }

        .panel {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #plot {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #hover-panel {
            background-color: #2a2a2a;
            padding: 0;
            overflow-y: auto;
        }

        /* Only apply 6:4 ratio in split views */
        .vertical .panel:first-child,
        .horizontal .panel:first-child {
            flex: 0.6;
        }

        .vertical #hover-panel,
        .horizontal #hover-panel {
            flex: 0.4;
        }

        /* Maximize heatmap space in horizontal view */
        .horizontal #plot {
            width: 100%;
            height: 100%;
            min-width: 0;
            min-height: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .horizontal .panel:first-child {
            min-width: 0;
            min-height: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .horizontal #plot>div {
            width: 100% !important;
            height: 100% !important;
        }

        #hover-content {
            display: none;
            /* Hide the hover content div */
        }

        .filtered-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-size: 11px;
            table-layout: fixed;
        }

        .filtered-table th,
        .filtered-table td {
            padding: 4px;
            text-align: left;
            border-bottom: 1px solid #3a3a3a;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 11px;
        }

        .filtered-table th {
            background-color: #3a3a3a;
            position: sticky;
            top: 0;
            padding: 4px;
            border-right: 1px solid #4a4a4a;
        }

        .filtered-table th:last-child {
            border-right: none;
        }

        .filtered-table td {
            border-right: 1px solid #3a3a3a;
        }

        .filtered-table td:last-child {
            border-right: none;
        }

        .filtered-table tr:hover {
            background-color: #3a3a3a;
        }

        .filtered-table td:nth-child(1),
        .filtered-table td:nth-child(4) {
            width: 35%;
        }

        .filtered-table td:nth-child(2),
        .filtered-table td:nth-child(3),
        .filtered-table td:nth-child(5),
        .filtered-table td:nth-child(6) {
            width: 3%;
            text-align: right;
            color: #888;
            padding: 4px 2px;
        }

        .filtered-table th:nth-child(2),
        .filtered-table th:nth-child(3),
        .filtered-table th:nth-child(5),
        .filtered-table th:nth-child(6) {
            width: 3%;
            text-align: right;
            padding: 4px 2px;
        }

        .filtered-table td:nth-child(7) {
            width: 21%;
        }

        .controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(42, 42, 42, 0.8);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
        }

        .button-group {
            display: flex;
            gap: 2px;
            width: 100%;
            padding: 5px;
            background-color: rgba(42, 42, 42, 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .button-group button {
            flex: 1;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
            color: white;
            font-size: 11px;
            min-height: 130px;
        }

        .slider-container label {
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            overflow: hidden;
        }

        .slider-container label span:first-child {
            flex-shrink: 0;
        }

        .slider-container label span:last-child {
            flex-shrink: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 5px;
            background-color: rgba(42, 42, 42, 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            width: 100%;
        }

        .slider-container input {
            width: 100%;
            margin: 0;
        }

        #histogram {
            width: 100%;
            height: 100px;
            margin-top: 2px;
        }

        #length-histogram {
            width: 100%;
            height: 100px;
            margin-top: 2px;
        }

        button {
            background-color: #3a3a3a;
            color: white;
            border: none;
            padding: 4px 8px;
            margin: 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        button:hover {
            background-color: #4a4a4a;
        }

        button.active {
            background-color: #5a5a5a;
        }
    </style>
</head>

<body>
    <div class="controls">
        <div class="button-group">
            <button id="single" class="active">Single</button>
            <button id="vertical">Vertical</button>
            <button id="horizontal">Horizontal</button>
        </div>
        <div class="slider-group">
            <div class="slider-container">
                <label for="threshold">Similarity: <span id="threshold-value">0.0</span> (<span
                        id="threshold-count">0</span> values)</label>
                <input type="range" id="threshold" min="0" max="1" step="0.01" value="0">
                <div id="histogram"></div>
            </div>
            <div class="slider-container">
                <label for="length-threshold">Length: <span id="length-value">0</span> chars (<span
                        id="length-count">0</span> values)</label>
                <input type="range" id="length-threshold" min="0" max="1000" step="1" value="0">
                <div id="length-histogram"></div>
            </div>
        </div>
    </div>
    <div class="container" id="container">
        <div class="panel">
            <div id="plot"></div>
        </div>
        <div class="panel" id="hover-panel" style="display: none;">
            <table class="filtered-table">
                <thead>
                    <tr>
                        <th id="row-header">Content 1</th>
                        <th>Offset 1</th>
                        <th>Length 1</th>
                        <th id="col-header">Content 2</th>
                        <th>Offset 2</th>
                        <th>Length 2</th>
                        <th>Similarity</th>
                    </tr>
                </thead>
                <tbody id="filtered-correlations">
                </tbody>
            </table>
        </div>
    </div>
    <script>
        // Helper function to wrap text
        function wrapText(text, maxLen = 50) {
            if (text.length <= maxLen) return text.trim();
            const remaining = text.length - maxLen;
            return text.slice(0, maxLen).trim() + ` (...${remaining} chars)`;
        }

        // Helper function to format hover text
        function formatHoverText(row, col, rowOff, rowLen, colOff, colLen, similarity) {
            return `[R${rowOff}: ${rowLen}]: ${wrapText(row)}<br>[C${colOff}: ${colLen}]: ${wrapText(col)}<br>S(${rowOff},${colOff}): ${similarity.toFixed(4)}`;
        }

        const data = {{ DATA }};
        let nRows = data.rowLabels.length;
        let nCols = data.colLabels.length;

        // Get filenames from the data
        const rowFile = data.rowFile || 'File 1';
        const colFile = data.colFile || 'File 2';

        // Update table headers with filenames
        document.getElementById('row-header').textContent = rowFile;
        document.getElementById('col-header').textContent = colFile;

        // Transpose the matrix if rows > columns to better utilize screen space
        let matrix = data.matrix;
        let rowLabels = data.rowLabels;
        let colLabels = data.colLabels;
        let rowFull = data.rowFull;
        let colFull = data.colFull;

        if (nRows > nCols) {
            // Transpose the matrix
            matrix = matrix[0].map((_, i) => matrix.map(row => row[i]));
            [rowLabels, colLabels] = [colLabels, rowLabels];
            [rowFull, colFull] = [colFull, rowFull];
            [nRows, nCols] = [nCols, nRows];
        }

        // Build hover text with full chunk text, wrapped if too long
        const hoverText = [];
        for (let i = 0; i < nRows; i++) {
            hoverText[i] = [];
            for (let j = 0; j < nCols; j++) {
                hoverText[i][j] = formatHoverText(
                    rowFull[i],
                    colFull[j],
                    i,
                    rowFull[i].length,
                    j,
                    colFull[j].length,
                    matrix[i][j]
                );
            }
        }

        // Calculate cell size based on screen dimensions
        function calculateCellSize() {
            const plotContainer = document.getElementById('plot').parentElement;
            const containerWidth = plotContainer.clientWidth;
            const containerHeight = plotContainer.clientHeight;

            // Use the smaller dimension to ensure square cells
            const cellSize = Math.min(
                containerWidth / nCols,
                containerHeight / nRows
            );

            // Calculate new dimensions to maintain square cells
            const newWidth = nCols * cellSize;
            const newHeight = nRows * cellSize;

            return { cellSize, newWidth, newHeight };
        }

        function updatePlotSize() {
            const { cellSize, newWidth, newHeight } = calculateCellSize();
            const isHorizontal = container.classList.contains('horizontal');

            if (isHorizontal) {
                // In horizontal mode, use the full container size
                const container = document.getElementById('plot').parentElement;
                layout.width = container.clientWidth;
                layout.height = container.clientHeight;
            } else {
                // In other modes, use calculated size
                layout.width = newWidth;
                layout.height = newHeight;
            }

            Plotly.relayout('plot', layout);
        }

        const trace = {
            z: matrix,
            x: colLabels,
            y: rowLabels,
            type: 'heatmap',
            colorscale: 'RdBu',
            hoverongaps: false,
            hoverinfo: 'text',
            text: hoverText,
            xgap: 0.2,
            ygap: 0.2,
            xmin: 0,
            xmax: 1,
            ymin: 0,
            ymax: 1,
            showscale: false
        };

        // Function to compute histogram data
        function computeHistogramData(matrix) {
            const values = matrix.flat().filter(val => !isNaN(val));
            const bins = 50;
            const min = 0;
            const max = 1;
            const binSize = (max - min) / bins;

            const histogram = new Array(bins).fill(0);
            values.forEach(val => {
                const binIndex = Math.min(Math.floor((val - min) / binSize), bins - 1);
                histogram[binIndex]++;
            });

            return {
                x: Array.from({ length: bins }, (_, i) => min + (i + 0.5) * binSize),
                y: histogram
            };
        }

        // Create histogram
        const histData = computeHistogramData(matrix);
        const histogramTrace = {
            x: histData.x,
            y: histData.y,
            type: 'bar',
            marker: {
                color: '#4a4a4a'
            },
            showlegend: false
        };

        const histogramLayout = {
            paper_bgcolor: '#2a2a2a',
            plot_bgcolor: '#2a2a2a',
            font: { color: '#ffffff' },
            margin: { l: 20, r: 20, t: 10, b: 20 },
            xaxis: {
                range: [0, 1],
                showgrid: false,
                zeroline: false,
                showticklabels: false
            },
            yaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false
            }
        };

        Plotly.newPlot('histogram', [histogramTrace], histogramLayout, {
            displayModeBar: false,
            responsive: true,
            staticPlot: true
        });

        // Function to compute histogram data for lengths
        function computeLengthHistogramData() {
            const lengths = [...rowFull, ...colFull].map(text => text.length);
            const maxLength = Math.max(...lengths);
            const bins = 50;
            const binSize = maxLength / bins;

            const histogram = new Array(bins).fill(0);
            lengths.forEach(len => {
                const binIndex = Math.min(Math.floor(len / binSize), bins - 1);
                histogram[binIndex]++;
            });

            return {
                x: Array.from({ length: bins }, (_, i) => (i + 0.5) * binSize),
                y: histogram,
                maxLength
            };
        }

        // Create length histogram
        const lengthHistData = computeLengthHistogramData();
        const lengthHistogramTrace = {
            x: lengthHistData.x,
            y: lengthHistData.y,
            type: 'bar',
            marker: {
                color: '#4a4a4a'
            },
            showlegend: false
        };

        const lengthHistogramLayout = {
            paper_bgcolor: '#2a2a2a',
            plot_bgcolor: '#2a2a2a',
            font: { color: '#ffffff' },
            margin: { l: 20, r: 20, t: 10, b: 20 },
            xaxis: {
                range: [0, lengthHistData.maxLength],
                showgrid: false,
                zeroline: false,
                showticklabels: false
            },
            yaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false
            }
        };

        Plotly.newPlot('length-histogram', [lengthHistogramTrace], lengthHistogramLayout, {
            displayModeBar: false,
            responsive: true,
            staticPlot: true
        });

        // Function to update heatmap based on thresholds
        function updateHeatmap(simThreshold, lenThreshold) {
            let aboveThreshold = 0;
            let aboveLengthThreshold = 0;
            const correlations = [];
            const filteredMatrix = matrix.map((row, i) =>
                row.map((val, j) => {
                    const rowLen = rowFull[i].length;
                    const colLen = colFull[j].length;
                    const meetsThresholds = val >= simThreshold && rowLen >= lenThreshold && colLen >= lenThreshold;

                    if (meetsThresholds) {
                        aboveThreshold++;
                        correlations.push({
                            row: rowFull[i],
                            col: colFull[j],
                            rowLen,
                            rowOff: i,
                            colLen,
                            colOff: j,
                            similarity: val
                        });
                    }
                    if (rowLen >= lenThreshold && colLen >= lenThreshold) {
                        aboveLengthThreshold++;
                    }

                    return meetsThresholds ? val : null;
                })
            );

            document.getElementById('threshold-count').textContent = aboveThreshold;
            document.getElementById('length-count').textContent = aboveLengthThreshold;

            // Update hover text to only show for non-filtered cells
            const filteredHoverText = hoverText.map((row, i) =>
                row.map((text, j) => filteredMatrix[i][j] !== null ? text : '')
            );

            // Update the plot with all necessary properties
            Plotly.react('plot', [{
                ...trace,
                z: filteredMatrix,
                text: filteredHoverText,
                hoverinfo: 'text',
                hoverongaps: false
            }], layout);

            // Update similarity histogram with threshold line
            const shapes = [{
                type: 'line',
                x0: simThreshold,
                x1: simThreshold,
                y0: 0,
                y1: Math.max(...histData.y),
                line: {
                    color: '#ff0000',
                    width: 2
                }
            }];

            Plotly.relayout('histogram', {
                shapes: shapes
            });

            // Update length histogram with threshold line
            const lengthShapes = [{
                type: 'line',
                x0: lenThreshold,
                x1: lenThreshold,
                y0: 0,
                y1: Math.max(...lengthHistData.y),
                line: {
                    color: '#ff0000',
                    width: 2
                }
            }];

            Plotly.relayout('length-histogram', {
                shapes: lengthShapes
            });

            // Sort by similarity in ascending order and take bottom 100
            correlations.sort((a, b) => a.similarity - b.similarity);
            const bottomCorrelations = correlations.slice(0, 100);

            // Update the filtered correlations table
            const tbody = document.getElementById('filtered-correlations');
            tbody.innerHTML = '';

            bottomCorrelations.forEach(corr => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td title="${corr.row}">${corr.row}</td>
                    <td>${corr.rowOff}</td>
                    <td>${corr.rowLen}</td>
                    <td title="${corr.col}">${corr.col}</td>
                    <td>${corr.colOff}</td>
                    <td>${corr.colLen}</td>
                    <td>${corr.similarity.toFixed(4)}</td>
                `;
                tbody.appendChild(row);
            });
        }

        const layout = {
            paper_bgcolor: '#1a1a1a',
            plot_bgcolor: '#1a1a1a',
            font: { color: '#ffffff' },
            xaxis: {
                showticklabels: false,
                showgrid: false,
                zeroline: false,
                autorange: true,
                fixedrange: true,
                showline: false,
                scaleanchor: 'y',
                scaleratio: 1
            },
            yaxis: {
                showticklabels: false,
                showgrid: false,
                zeroline: false,
                autorange: 'reversed',
                fixedrange: true,
                showline: false
            },
            autosize: true,
            margin: { l: 0, r: 0, t: 0, b: 0 },
            width: nCols * calculateCellSize().cellSize,
            height: nRows * calculateCellSize().cellSize
        };

        Plotly.newPlot('plot', [trace], layout, { responsive: true });

        // Handle window resize
        window.addEventListener('resize', updatePlotSize);

        // Handle hover events
        document.getElementById('plot').on('plotly_hover', function (data) {
            // Remove hover text handling since we don't need it anymore
        });

        // Handle layout switching
        const container = document.getElementById('container');
        const hoverPanel = document.getElementById('hover-panel');
        const buttons = document.querySelectorAll('.controls button');

        function setLayout(layout) {
            buttons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(layout).classList.add('active');

            container.className = 'container';
            hoverPanel.style.display = 'none';

            if (layout === 'vertical') {
                container.classList.add('vertical');
                hoverPanel.style.display = 'block';
            } else if (layout === 'horizontal') {
                container.classList.add('horizontal');
                hoverPanel.style.display = 'block';
            }

            // Update plot size after layout change
            setTimeout(updatePlotSize, 0);
        }

        buttons.forEach(button => {
            button.addEventListener('click', () => setLayout(button.id));
        });

        // Add threshold slider event listeners
        const thresholdSlider = document.getElementById('threshold');
        const thresholdValue = document.getElementById('threshold-value');
        const lengthSlider = document.getElementById('length-threshold');
        const lengthValue = document.getElementById('length-value');

        thresholdSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            thresholdValue.textContent = value.toFixed(2);
            updateHeatmap(value, parseInt(lengthSlider.value));
        });

        lengthSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            lengthValue.textContent = value;
            updateHeatmap(parseFloat(thresholdSlider.value), value);
        });

        // Initial update
        updateHeatmap(0, 0);
    </script>
</body>

</html>